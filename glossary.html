

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Glossary &mdash; lambeq 0.1.3.dev15+g357fb89 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="Quantum pipeline using t|ket&gt; backend" href="examples/quantum_pipeline_tket.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> lambeq
          

          
            
            <img src="_static/lambeq_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.1.3.dev15+g357fb89
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pipeline.html">Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="parsing.html">Syntactic parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="string_diagrams.html">String diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="discopy.html">DisCoPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributing to lambeq</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tutorials/sentence-input.html">Step 1. Sentence input</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/rewrite.html">Step 2. Diagram rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/parameterise.html">Step 3. Parameterisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="training.html">Step 4: Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced: DisCoPy usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/extend-lambeq.html">Advanced: Extending lambeq</a></li>
</ul>
<p class="caption"><span class="caption-text">Toolkit</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="notebooks.html">Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release notes</a></li>
</ul>
<p class="caption"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://qnlp.cambridgequantum.com/downloads.html">Resources</a></li>
<li class="toctree-l1"><a class="reference external" href="https://qnlp.cambridgequantum.com/generate.html">Web demo</a></li>
<li class="toctree-l1"><a class="reference external" href="https://discopy.readthedocs.io">DisCoPy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">lambeq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Glossary</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            
              <a href="https://github.com/CQCL/lambeq/blob/main/docs/glossary.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="glossary">
<span id="sec-glossary"></span><h1>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h1>
<dl class="glossary simple">
<dt id="term-adjoint">adjoint</dt><dd><p>In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, each <a class="reference internal" href="#term-pregroup-grammar"><span class="xref std std-term">pregroup</span></a> type <span class="math notranslate nohighlight">\(p\)</span> has a left (<span class="math notranslate nohighlight">\(p^l\)</span>) and a right (<span class="math notranslate nohighlight">\(p^r\)</span>) adjoint, which are used to represent arguments in composite types. For example, a transitive verb has type <span class="math notranslate nohighlight">\(n^r \cdot s \cdot n^l\)</span>, meaning it expects a noun argument on both sides in order to return a sentence.</p>
</dd>
<dt id="term-ansatz-plural-ansatze">ansatz (plural: ansätze)</dt><dd><p>A map that determines choices such as the number of <a class="reference internal" href="#term-qubit"><span class="xref std std-term">qubits</span></a> that every wire of a <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagram</span></a> is associated with and the concrete parameterised quantum states that correspond to each word. For the classical case, an ansatz determines the number of dimensions associated to each type, and the way that large tensors are represented as <a class="reference internal" href="#term-matrix-product-state-MPS"><span class="xref std std-term">matrix product states</span></a>.</p>
</dd>
<dt id="term-bag-of-words">bag-of-words</dt><dd><p>A <a class="reference internal" href="#term-compositional-model"><span class="xref std std-term">compositional model</span></a> of meaning which represents a sentence as a multiset of words; that is, it does not take into account the order of words or any other syntactic relationship between them.</p>
</dd>
<dt id="term-cap">cap</dt><dd><p>A special morphism in a <a class="reference internal" href="#term-rigid-category"><span class="xref std std-term">rigid category</span></a>, which, together with a <a class="reference internal" href="#term-cup"><span class="xref std std-term">cup</span></a> morphism, obey certain conditions called <a class="reference internal" href="#term-snake-equations"><span class="xref std std-term">snake equations</span></a>. In diagrammatic form, a cap is depicted as a wire with downward concavity (<span class="math notranslate nohighlight">\(\cap\)</span>). In the context of <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a>, a cap is mostly used to “bridge” disconnected wires in order to alter the normal “flow” of information from one word to another, for example in cases such as <em>type-raising</em>.</p>
</dd>
<dt id="term-category">category</dt><dd><p>In <em>category theory</em>, a category is a mathematical structure that consists of a collection of <em>objects</em> and a collection of <em>morphisms</em> between objects, forming a labelled directed graph. A category has two basic properties: the ability to compose the arrows associatively, and the existence of an identity arrow for each object. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> structures are expressed in terms of a <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal category</span></a>.</p>
</dd>
<dt id="term-categorical-quantum-mechanics-CQM">categorical quantum mechanics (CQM)</dt><dd><p>The study of quantum foundations and quantum information using paradigms from mathematics and computer science, specifically <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal categories</span></a>. The primitive objects of study are physical processes, and the different ways that these can be composed. The field was originated by Samson Abramsky and Bob Coecke in 2004 <a class="reference internal" href="bibliography.html#ac2004" id="id1"><span>[AC2004]</span></a>.</p>
</dd>
<dt id="term-CCGBank">CCGBank</dt><dd><p>The <a class="reference internal" href="#term-Combinatory-Categorial-Grammar-CCG"><span class="xref std std-term">CCG</span></a> version of <em>Penn Treebank</em>, a corpus of over 49,000 human-annotated syntactic trees created by Julia Hockenmaier and Mark Steedman <a class="reference internal" href="bibliography.html#hs2007" id="id2"><span>[HS2007]</span></a>.</p>
</dd>
<dt id="term-Combinatory-Categorial-Grammar-CCG">Combinatory Categorial Grammar (CCG)</dt><dd><p>A grammar formalism inspired by combinatory logic, and developed by Mark Steedman <a class="reference internal" href="bibliography.html#ste2000" id="id3"><span>[Ste2000]</span></a>. It defines a number of combinators (application, composition, and type-raising being the most common) which operate on syntactically-typed lexical items, by means of natural deduction style proofs. CCG is categorised as a <em>mildly context-sensitive</em> grammar, standing in between context-free and context-sensitive in Chomsky hierarchy and providing a nice trade-off between expressive power and computational complexity.</p>
</dd>
<dt id="term-compact-closed-category">compact closed category</dt><dd><p>A symmetric <a class="reference internal" href="#term-rigid-category"><span class="xref std std-term">rigid category</span></a>. The symmetry of the category causes the left and right duals of an object to coincide: <span class="math notranslate nohighlight">\(A^l=A^r=A^*\)</span>. A <a class="reference internal" href="#term-pregroup-grammar"><span class="xref std std-term">pregroup grammar</span></a> is often referred to as a non-symmetric compact closed category.</p>
</dd>
<dt id="term-compositional-model">compositional model</dt><dd><p>A model that produces semantic representations of sentences by composing together the semantic representations of the words within them. An example of a compositional model is <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a>.</p>
</dd>
<dt id="term-cup">cup</dt><dd><p>A special morphism in a <a class="reference internal" href="#term-rigid-category"><span class="xref std std-term">rigid category</span></a>, which, together with a <a class="reference internal" href="#term-cap"><span class="xref std std-term">cap</span></a> morphism, obey certain conditions called <a class="reference internal" href="#term-snake-equations"><span class="xref std std-term">snake equations</span></a>. In diagrammatic form, a cup is depicted as a wire with upward concavity (<span class="math notranslate nohighlight">\(\cup\)</span>). In the context of <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a>, a cup usually represents a tensor contraction between two word representations.</p>
</dd>
<dt id="term-depccg">depccg</dt><dd><p>A statistical <a class="reference internal" href="#term-Combinatory-Categorial-Grammar-CCG"><span class="xref std std-term">CCG</span></a> <a class="reference internal" href="#term-parser"><span class="xref std std-term">parser</span></a> for English and Japanese <a class="reference internal" href="bibliography.html#ynm2017" id="id4"><span>[YNM2017]</span></a>.</p>
</dd>
<dt id="term-DisCoCat">DisCoCat</dt><dd><p>The DIStributional COmpositional CATegorical model of natural language meaning developed by Bob Coecke, Mehrnoosh Sadrzadeh and Steve Clark <a class="reference internal" href="bibliography.html#csc2010" id="id5"><span>[CSC2010]</span></a>.  The model applies a <a class="reference internal" href="#term-functor"><span class="xref std std-term">functor</span></a> <span class="math notranslate nohighlight">\(F: \textrm{Grammar} \to \textrm{Meaning}\)</span> whose left-hand side is a free pregroup over a partially ordered set of basic grammar types, and the right-hand side is the category whose morphisms describe a sequence of operations that can be evaluated on a classical or quantum computer.</p>
</dd>
<dt id="term-DisCoPy">DisCoPy</dt><dd><p>DIStributional COmpositional PYthon. A Python library for working with <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal categories</span></a> <a class="reference internal" href="bibliography.html#ftc2020" id="id6"><span>[FTC2020]</span></a>. DisCoPy is responsible for all the low-level processing in <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, and includes abstractions for creating all standard <a class="reference internal" href="#term-quantum-gate"><span class="xref std std-term">quantum gates</span></a> and building <a class="reference internal" href="#term-quantum-circuit"><span class="xref std std-term">quantum circuits</span></a>. Additionally, it is equipped with many language-related features, such as support for <a class="reference internal" href="#term-pregroup-grammar"><span class="xref std std-term">pregroup grammars</span></a> and <a class="reference internal" href="#term-functor"><span class="xref std std-term">functors</span></a> for implementing <a class="reference internal" href="#term-compositional-model"><span class="xref std std-term">compositional models</span></a>.</p>
</dd>
<dt id="term-Frobenius-algebra">Frobenius algebra</dt><dd><p>In the context of a <a class="reference internal" href="#term-symmetric-monoidal-category"><span class="xref std std-term">symmetric monoidal category</span></a>, a Frobenius algebra provides morphisms <span class="math notranslate nohighlight">\(\Delta: A \to A\otimes A\)</span> and <span class="math notranslate nohighlight">\(\mu: A\otimes A \to A\)</span> for any object <span class="math notranslate nohighlight">\(A\)</span>, satisfying certain conditions (the so-called Frobenius equations) and implementing the notion of a <a class="reference internal" href="#term-spider"><span class="xref std std-term">spider</span></a>. In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> and <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a>, spiders can be used to implement <a class="reference internal" href="#term-rewrite-rule"><span class="xref std std-term">rewrite rules</span></a> <a class="reference internal" href="bibliography.html#kea2014" id="id7"><span>[Kea2014]</span></a> <a class="reference internal" href="bibliography.html#kar2016" id="id8"><span>[Kar2016]</span></a> <a class="reference internal" href="bibliography.html#scc2014a" id="id9"><span>[SCC2014a]</span></a> <a class="reference internal" href="bibliography.html#scc2014b" id="id10"><span>[SCC2014b]</span></a>.</p>
</dd>
<dt id="term-functor">functor</dt><dd><p>A structure-preserving transformation from one <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> to another. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>’s <a class="reference internal" href="pipeline.html#sec-pipeline"><span class="std std-ref">pipeline</span></a> is essentially a chain of functorial transformations from a grammar category to a category accommodating the meaning of a sentence.</p>
</dd>
<dt id="term-IQP-circuit">IQP circuit</dt><dd><p>Instantaneous Quantum Polynomial. A circuit which interleaves layers of Hadamard <a class="reference internal" href="#term-quantum-gate"><span class="xref std std-term">quantum gates</span></a> with diagonal unitaries.</p>
</dd>
<dt id="term-matrix-product-state-MPS">matrix product state (MPS)</dt><dd><p>A factorization of a large tensor into a chain-like product of smaller tensors. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> is equipped with <a class="reference internal" href="#term-ansatz-plural-ansatze"><span class="xref std std-term">ansätze</span></a> that implement various forms of matrix product states, allowing the execution of large <a class="reference internal" href="#term-tensor-network"><span class="xref std std-term">tensor networks</span></a> on classical hardware.</p>
</dd>
<dt id="term-monoidal-category">monoidal category</dt><dd><p>A <a class="reference internal" href="#term-category"><span class="xref std std-term">category</span></a> equipped with the monoidal product <span class="math notranslate nohighlight">\(\otimes\)</span> and monoidal unit <span class="math notranslate nohighlight">\(I\)</span>, providing an abstraction suitable for quantum computation.  <a class="reference internal" href="#term-categorical-quantum-mechanics-CQM"><span class="xref std std-term">Categorical quantum mechanics (CQM)</span></a> and <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a> are both based on the mathematical framework of monoidal categories.</p>
</dd>
<dt id="term-natural-language-processing-NLP">natural language processing (NLP)</dt><dd><p>The use of computational methods for solving language-related problems.</p>
</dd>
<dt id="term-pregroup-grammar">pregroup grammar</dt><dd><p>A grammar formalism developed by Joachim Lambek in 1999 <a class="reference internal" href="bibliography.html#lam1999" id="id11"><span>[Lam1999]</span></a> based on the notion of a <em>pregroup</em>. Pregroup grammars are closely related to categorial grammars (such as <a class="reference internal" href="#term-Combinatory-Categorial-Grammar-CCG"><span class="xref std std-term">CCG</span></a>). In category-theoretic terms, a pregroup grammar forms a <a class="reference internal" href="#term-rigid-category"><span class="xref std std-term">rigid category</span></a>, sometimes also referred to as a non-symmetric <a class="reference internal" href="#term-compact-closed-category"><span class="xref std std-term">compact closed category</span></a>.</p>
</dd>
<dt id="term-pytket">pytket</dt><dd><p>A Python interface for the <a class="reference internal" href="#term-tket"><span class="xref std std-term">tket</span></a> compiler.</p>
</dd>
<dt id="term-qiskit">qiskit</dt><dd><p>An open-source SDK developed by IBM Research for working with quantum computers at the level of circuits, pulses, and algorithms.</p>
</dd>
<dt id="term-quantum-circuit">quantum circuit</dt><dd><p>A sequence of <a class="reference internal" href="#term-quantum-gate"><span class="xref std std-term">quantum gates</span></a>, measurements, and initializations of <a class="reference internal" href="#term-qubit"><span class="xref std std-term">qubits</span></a> that expresses a computation in a quantum computer. The purpose of <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> is to convert sentences into quantum circuits that can be evaluated on quantum hardware.</p>
</dd>
<dt id="term-quantum-gate">quantum gate</dt><dd><p>An atomic unit of computation operating on a small number of <a class="reference internal" href="#term-qubit"><span class="xref std std-term">qubits</span></a>. Quantum gates are the building blocks of <a class="reference internal" href="#term-quantum-circuit"><span class="xref std std-term">quantum circuits</span></a>.</p>
</dd>
<dt id="term-quantum-NLP-QNLP">quantum NLP (QNLP)</dt><dd><p>The design and implementation of <a class="reference internal" href="#term-natural-language-processing-NLP"><span class="xref std std-term">NLP</span></a> models that exploit certain quantum phenomena such as superposition, entanglement, and interference to perform language-related tasks on quantum hardware.</p>
</dd>
<dt id="term-qubit">qubit</dt><dd><p>The quantum analog of a bit and the most basic unit of information carrier in a quantum computer. It is associated with a property of a physical system such as the spin of an electron (“up” or “down” along some axis), and has a state that lives in a 2-dimensional complex vector space.</p>
</dd>
<dt id="term-reader">reader</dt><dd><p>In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, an object that translates a sentence into a <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagram</span></a> based on a certain <a class="reference internal" href="#term-compositional-model"><span class="xref std std-term">compositional scheme</span></a>. Versions of a <a class="reference internal" href="#term-bag-of-words"><span class="xref std std-term">bag-of-words</span></a> model and a <a class="reference internal" href="#term-word-sequence-model"><span class="xref std std-term">word-sequence model</span></a> are implemented in <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> using readers.</p>
</dd>
<dt id="term-rewrite-rule">rewrite rule</dt><dd><p>A <a class="reference internal" href="#term-functor"><span class="xref std std-term">functorial</span></a> transformation that changes the wiring of a specific box (representing a word) in a <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagram</span></a> with the goal to simplify the diagram or to make it more amenable to implementation on the hardware of choice.</p>
</dd>
<dt id="term-rigid-category">rigid category</dt><dd><p>A <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal category</span></a> where every object <span class="math notranslate nohighlight">\(A\)</span> has a left dual <span class="math notranslate nohighlight">\(A^l\)</span> and a right dual <span class="math notranslate nohighlight">\(A^r\)</span>, both equipped with <a class="reference internal" href="#term-cup"><span class="xref std std-term">cup</span></a> and <a class="reference internal" href="#term-cap"><span class="xref std std-term">cap</span></a> morphisms obeying the so-called <a class="reference internal" href="#term-snake-equations"><span class="xref std std-term">snake equations</span></a>. A <a class="reference internal" href="#term-pregroup-grammar"><span class="xref std std-term">pregroup grammar</span></a> is an example of a rigid category.</p>
</dd>
<dt id="term-snake-equations">snake equations</dt><dd><p>Identities that hold between the dual objects of a <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal category</span></a> and allow the “yanking” of wires and the rewriting and simplification of diagrams. In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> and <a class="reference internal" href="#term-DisCoPy"><span class="xref std std-term">DisCoPy</span></a>, the <a class="reference external" href="https://discopy.readthedocs.io/en/main/_autosummary/discopy.monoidal.Diagram.html#discopy.monoidal.Diagram.normal_form" title="(in discopy)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">monoidal.Diagram.normal_form()</span></code></a> method uses the snake equations in order to “stretch” the wires of a diagram and provide a normal form for it.</p>
</dd>
<dt id="term-spider">spider</dt><dd><p>Another name for a <a class="reference internal" href="#term-Frobenius-algebra"><span class="xref std std-term">Frobenius algebra</span></a>.</p>
</dd>
<dt id="term-string-diagram">string diagram</dt><dd><p>A diagrammatic representation that reflects computations in a <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal category</span></a>, an abstraction well-suited to model the way a quantum computer works and processes data. String diagrams are the native form of representing sentences in <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> and <a class="reference internal" href="#term-DisCoCat"><span class="xref std std-term">DisCoCat</span></a>, since they remain close to quantum circuits, yet are independent of any low-level design decisions depending on hardware. They can be seen as enriched <a class="reference internal" href="#term-tensor-network"><span class="xref std std-term">tensor networks</span></a>.</p>
</dd>
<dt id="term-syntax-tree">syntax tree</dt><dd><p>A hierarchical representation of a sentence that reflects the syntactic relationships between the words, given a specific grammar. The first step in <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>’s <a class="reference internal" href="pipeline.html#sec-pipeline"><span class="std std-ref">pipeline</span></a> given a sentence is to produce a <a class="reference internal" href="#term-Combinatory-Categorial-Grammar-CCG"><span class="xref std std-term">CCG</span></a> syntax tree for it, which is then converted into a <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagram</span></a>.</p>
</dd>
<dt id="term-symbol">symbol</dt><dd><p>In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, a symbol corresponds to a trainable part of a <a class="reference internal" href="#term-tensor-network"><span class="xref std std-term">tensor network</span></a> or a <a class="reference internal" href="#term-quantum-circuit"><span class="xref std std-term">quantum circuit</span></a>. In the classical case, symbols are associated with tensors in a <a class="reference internal" href="#term-tensor-network"><span class="xref std std-term">tensor network</span></a>, while in the quantum case symbols represent numbers expressing rotation angles on <a class="reference internal" href="#term-qubit"><span class="xref std std-term">qubits</span></a> in a <a class="reference internal" href="#term-quantum-circuit"><span class="xref std std-term">quantum circuit</span></a>.</p>
</dd>
<dt id="term-symmetric-monoidal-category">symmetric monoidal category</dt><dd><p>A <a class="reference internal" href="#term-monoidal-category"><span class="xref std std-term">monoidal category</span></a> equipped with <a class="reference internal" href="#term-swap"><span class="xref std std-term">swaps</span></a>, such that, for any two objects <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, we have <span class="math notranslate nohighlight">\(A\otimes B \cong B\otimes A\)</span>. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>’s string diagrams are expressed in a symmetric monoidal category.</p>
</dd>
<dt id="term-swap">swap</dt><dd><p>A crossing of wires in a <a class="reference internal" href="#term-symmetric-monoidal-category"><span class="xref std std-term">symmetric monoidal category</span></a>. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code> uses swaps in order to translate <em>crossed composition</em> rules in <a class="reference internal" href="#term-Combinatory-Categorial-Grammar-CCG"><span class="xref std std-term">CCG</span></a> derivations into a <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagram</span></a> form <a class="reference internal" href="bibliography.html#yk2021" id="id12"><span>[YK2021]</span></a>.</p>
</dd>
<dt id="term-tensor-network">tensor network</dt><dd><p>A directed acyclic graph expressing a (multi-)linear computation between tensors. The vertices of the graph are multi-linear tensor maps, and the edges correspond to vector spaces. Tensor networks have found many applications in quantum mechanics. <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>’s <a class="reference internal" href="#term-string-diagram"><span class="xref std std-term">string diagrams</span></a> can be seen as tensor networks with additional properties.</p>
</dd>
<dt id="term-tensor-train">tensor train</dt><dd><p>A basic <a class="reference internal" href="#term-tensor-network"><span class="xref std std-term">tensor network</span></a> in which all tensors have the same shape and each tensor is connected to the next one following a predefined order. In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, tensor trains are used to implement <a class="reference internal" href="#term-word-sequence-model"><span class="xref std std-term">word-sequence models</span></a>.</p>
</dd>
<dt id="term-tket">tket</dt><dd><p>Stylised <span class="math notranslate nohighlight">\(\textrm{t}|\textrm{ket}\rangle\)</span>. A quantum software development platform produced by Cambridge Quantum. The heart of <code class="docutils literal notranslate"><span class="pre">tket</span></code> is a language-agnostic optimising compiler designed to generate code for a variety of NISQ devices, which has several features designed to minimise the influence of device error.</p>
</dd>
<dt id="term-parser">parser</dt><dd><p>A statistical tool that converts a sentence into a hierarchical representation that reflects the syntactic relationships between the words (a <a class="reference internal" href="#term-syntax-tree"><span class="xref std std-term">syntax tree</span></a>) based on a specific grammar formalism. A parser usually works in two steps: first, a POS-tagger assigns part-of-speech tags to the words in a sentence; next, the parser uses its statistical model to try and combine the words into meaningful compositions following the rules of the grammar formalism.</p>
</dd>
<dt id="term-word-sequence-model">word-sequence model</dt><dd><p>A <a class="reference internal" href="#term-compositional-model"><span class="xref std std-term">compositional model</span></a> that respects the order of words in a sentence, but it does not take into account any other syntactic information. In <code class="docutils literal notranslate"><span class="pre">lambeq</span></code>, the model is implemented as a <a class="reference internal" href="#term-tensor-train"><span class="xref std std-term">tensor train</span></a>.</p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="bibliography.html" class="btn btn-neutral float-right" title="Bibliography" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="examples/quantum_pipeline_tket.html" class="btn btn-neutral float-left" title="Quantum pipeline using t|ket&gt; backend" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Cambridge Quantum Computing Ltd..

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>