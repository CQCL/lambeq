{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Training hybrid models using the Pennylane backend\n",
    "\n",
    "In this example, we will first train a pure quantum model using PennyLane and PyTorch to classify whether a sentence is about cooking or computing. We will then train a hybrid model that takes in pairs of sentences and determines whether they are talking about the same or different topics."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "BATCH_SIZE = 10\n",
    "EPOCHS = 15\n",
    "SEED = 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import random\n",
    "import numpy as np\n",
    "\n",
    "torch.manual_seed(SEED)\n",
    "random.seed(SEED)\n",
    "np.random.seed(SEED)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Read in the data and create diagrams"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_data(filename):\n",
    "    labels, sentences = [], []\n",
    "    with open(filename) as f:\n",
    "        for line in f:\n",
    "            t = float(line[0])\n",
    "            labels.append([t, 1-t])\n",
    "            sentences.append(line[1:].strip())\n",
    "    return labels, sentences\n",
    "\n",
    "\n",
    "train_labels, train_data = read_data('datasets/mc_train_data.txt')\n",
    "dev_labels, dev_data = read_data('datasets/mc_dev_data.txt')\n",
    "test_labels, test_data = read_data('datasets/mc_test_data.txt')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Tagging sentences.\n",
      "Parsing tagged sentences.\n",
      "Turning parse trees to diagrams.\n",
      "Tagging sentences.\n",
      "Parsing tagged sentences.\n",
      "Turning parse trees to diagrams.\n",
      "Tagging sentences.\n",
      "Parsing tagged sentences.\n",
      "Turning parse trees to diagrams.\n"
     ]
    }
   ],
   "source": [
    "from lambeq import BobcatParser\n",
    "\n",
    "reader = BobcatParser(verbose='text')\n",
    "\n",
    "raw_train_diagrams = reader.sentences2diagrams(train_data)\n",
    "raw_dev_diagrams = reader.sentences2diagrams(dev_data)\n",
    "raw_test_diagrams = reader.sentences2diagrams(test_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Remove cups"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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sbGxevfddxUTE6P3339fnTp1qv2dhFHnzp3T8OHDtWzZMkVFRZmO873Y6gQscuzYMe3evVuS9MYbb6h3797XXP7AAw9o586dNed358+f1+HDh2su37BhQ83fV1eC5eXluvvuuyVJf/7zn39w7oEDB+rll1+u+by4uFiS9NFHHykiIkIpKSmKjo7Wf/7zn9u8lzDFcRxNnTpVDzzwgCZOnGg6zg+i+ACLdOzYUWlpaercubPOnDmjadOmXXN5mzZtlJmZqTFjxigyMlK9evW6pojOnDmjyMhIrVixQi+88IKkrx/EMmLECHXv3l133nnnD8790ksvqaCgQJGRkbrvvvuUnp4u6esXLA4PD1dkZKTq16+vwYMHu+GewxPS09NVUlKitLQ001GuK8BxHMd0CF+RnJys0NBQJScnm47i1Vq0aCGXy+WVe/s2c7lcGjJkiEpKSmp1+5CQEBUUFFy33GCv/Px8xcbGaufOnerQoYPpONfFig8AcFs+//xzjRgxQunp6V5fehIPbgGsERISUuvVnvT1ihH4turqaiUmJio+Pl5xcXGm49wUVnwAgFpbunSpysvLtXTpUtNRbhorPgBArWzbtk1paWnKz89X/fr1Tce5aaz4AAC37NNPP9X48eO1du3amqez+AqKDwBwS65cuaJRo0Zp+vTp6tevn+k4t4ziAwDckvnz56t58+aaP3++6Si1whkfAOCmbd68WVlZWSoqKlJgoG+unSg+AMBNOXLkiB5//HG98847atWqlek4teabdQ0A8KiKigrFx8dr0aJFio6ONh3ntlB8AIAbSkpKUnh4uB5//HHTUW4bW52oc/Xr19fo0aPd9rwex3HkOI7Pni/4C8dxVF1draCgINNRrFdVVeXWn0NFRYWOHz+uvLw8r3tT2dqg+FDntm3bprKyMreNv2XLFh06dIgXCzfs8OHDWrVqlZ577jnTUax29akFmzdvdus80dHRatq0qVvn8BSKD3UuMjJSkZGRbhv/xIkTqqio0NChQ902B24sLy9PGzZs4Odg2KVLlxQYGMjP4RawVwQAsArFBwCwCsUHALAKxQcAsArFBwCwCsUHALhGZmamkpKSTMdwG4oP+JbKykrTEQC4EcUHv+dyudS5c2dNmTJFYWFhGjhwoCoqKq65TmpqqsaPH6+YmBiNHz/eUFL/dv78ecXGxqpLly4KDw/Xhg0bTEey0s38Pvg7ig9WOHLkiKZPn67S0lK1aNFCmzZt+s51Dhw4oJycHK1bt85AQv+XnZ2t4OBg7d27VyUlJRo0aJDpSNa6md8Hf0bxwQrt27dXVFSUJKl79+5yuVzfuc6wYcPUqFEjzwazSEREhLZu3aqUlBTt2LFDzZs3Nx3JWjfz++DPKD5YoUGDBjUfBwUFfe85XpMmTTwZyTqhoaEqKipSRESEFixYoMWLF5uOZK2b+X3wZ7xWJwCPOH78uFq1aqVx48apRYsWysjIMB0JlqL4YK309HRJ8ov3F/MF+/fv15w5cxQYGKj69etr5cqVpiPhG2z6fQhwHMcxHcJXJCcnKzQ0lLfDMSwjI0O5ubmsGAzLy8tTUlKS8vLyTEex2qVLl9SsWTNdunTJdBSfwRkfAMAqFB8AwCoUHwDAKhQfAMAqFB8AwCoUHwDAKhQfAMAqFB8AwCoUHwDAKhQfAMAqFB8AwCoUHwDAKhQfAMAqFB8AwCoUHwDAKhQfAPiwgIAAde3a1XQMn8I7sAOAG+3bt0+/+MUvVF5e7tZ5AgIC3Dp+u3bt5HK53DqHp7DiAwA3OXv2rOLi4pSWlibHcXz6T1lZmelvZ52h+ADADaqrq5WYmKhf//rXSkhIMB0H38BWJwC4wdKlS/X5558rKyvLdBR8C8UHAHVsy5YtSktLU0FBgX70ox+ZjoNvofgAoA65XC4lJiZqw4YNCg4ONh0H34MzPgCoIxcvXlR8fLzmzp2rhx56yHQc/ACKDwDqSHJysu655x7NmjXLdBRcB1udAFAHMjIytHPnTu3Zs8ftz6nD7aH4AOA2FRQUaP78+dqxY4fuuOMO03FwA2x1AsBtOH36tOLj45Wenq5OnTqZjoObQPEBQC1VVVUpISFBI0eO1PDhw03HwU2i+ACgllJTU3X58mU9/fTTpqPgFlB8AFALb731ljIzM7V+/XrVq1c3D5c4f/68YmNj1aVLF4WHh2vDhg1avHixoqOjFR4erscee0yO40iS+vbtq4KCAklfb7eGhIRI+noVOnv2bIWHhysyMlIvv/yyJKmwsFAPPfSQunfvrl/96lf67LPP6iSzL6L4AOAWHT16VJMmTdLf/vY33XXXXXU2bnZ2toKDg7V3716VlJRo0KBBSkpKUn5+vkpKSlRRUaG33377umOsXr1aLpdLxcXF2rdvnxISEnTlyhUlJycrKytLhYWFmjhxon73u9/VWW5fQ/EBwC24cOGC4uLilJqaql69etXp2BEREdq6datSUlK0Y8cONW/eXP/61790//33KyIiQv/85z9VWlp63TFycnI0derUmlVoq1atdOjQIZWUlGjAgAGKiorSkiVL9Mknn9Rpdl/C0xkA4CY5jqOpU6cqKipK06ZNq/PxQ0NDVVRUpHfffVcLFixQv379al7zs23btkpNTdXFixclSfXq1VN1dbUk1XzternDwsK0e/fuOs/si1jxAcBNeuWVV7Rv3z6lp6e75Unqx48fV+PGjTVu3DjNmTNHRUVFkqQ777xT586du+adHkJCQlRYWChJ13x9wIABWrVqlSorKyVJX3zxhTp27KhTp07VFN+VK1duuHL0Z6z4AOAm7Nq1S4sWLdLu3bvVuHFjt8yxf/9+zZkzR4GBgapfv75WrlypN998U+Hh4frJT36i6OjomuvOnj1bI0eO1OrVqxUbG1vz9cmTJ+vw4cOKjIxU/fr1NWXKFCUlJSkrK0u/+c1vVF5ersrKSs2cOVNhYWFuuR/eLsC5+hAh3FBycrJCQ0OVnJxsOorVMjIylJubq4yMDNNRrJaXl6ekpCTl5eWZjuJ2J06cUI8ePbRy5UoNGTLEdBwjAgIC5C91wVYnAFxHZWWlRo0apQkTJlhbev6G4gOA65g/f74aNmyohQsXmo6COsIZHwD8gKysLGVlZamgoEBBQUGm46COUHwA8D0OHjyoadOmKTs7W61btzYdB3WIrU4A+JavvvpKcXFxWrZsmbp37246DuoYxQcA3+A4jiZOnKg+ffpo4sSJpuPADdjqBIBveP755+VyubR27VrTUeAmFB8A/L/t27frmWee0Z49e9SwYUPTceAmbHUCgKRPP/1UY8eO1dq1a9WuXTvTceBGFB8A612+fFkjRoxQUlKSBgwYYDoO3IziA2C9p556Sm3atNG8efNMR4EHcMYHwGqvv/66srOzlZ+fr8BA1gI2oPgAWG3t2rU6evSoWrZsaTqKV/Onc0+KD4DV3n//fdMR4GGs6wEAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofgAAFah+AAAVqH4AABWofhuQdu2bdWmTRvTMazXunVrtWvXznQMAD6qnukAdaW0tFS9e/fW2bNn3T7XmDFj3D4HbuwPf/iDW8dv166dXC6XW+cA4Hl+UXznz5/XiBEj9MILL+jRRx81HQd+IiAgwHQEAG7gF1ud06dPV8+ePSk9AMAN+fyKLzMzU3l5ecrPzzcdBQDgA3y6+EpLSzVnzhxt375dTZo0MR0HAOADfHar8+q53jPPPKOwsDDTcQAAPsJni49zPQBAbfjkVifnegCA2vK54uNcDwBwO3xqq5NzPQDA7fKp4uNcDwBwu3ym+K6e66WlpZmO4pVCQkJ0+vTp73z9wQcflCS5XC6Fh4dLkrZv364hQ4ZIki5duqT+/fsrKipKGzZs+MHxMzMzlZSU5IbkAOBZPnHGx7le7e3ateu6l3/44YeSpOLiYg+kAQDzvH7Fx7ned50/f16xsbHq0qWLwsPDr1mpVVRUaPDgwXr11VclSU2bNv3BcU6ePKlx48YpPz9fUVFR+uijj65ZORYUFKhv375uvS8A4GleX3yc631Xdna2goODtXfvXpWUlGjQoEGSpHPnzmno0KEaM2aMpkyZcsNxfvzjHysjI0N9+vRRcXGx7r33XndHBwDjvLr4ONf7fhEREdq6datSUlK0Y8cONW/eXJL08MMPa8KECUpMTDScEAC8l9cW39VzvY0bN3Ku9y2hoaEqKipSRESEFixYoMWLF0uSYmJilJ2dLcdxaj12vXr1VF1dLUm6ePFineQFAG/ilcXHud71HT9+XI0bN9a4ceM0Z84cFRUVSZIWL16sli1bavr06bUeOyQkRIWFhZKkTZs21UleAPAmXll8nOtd3/79+9WzZ09FRUVp0aJFWrBgQc1lK1asUEVFhebOnVursRcuXKgZM2aoR48eCgoKqqvIAOA1Apzb2Rdzg8zMTC1fvlz5+flsccKogICA29o29nd5eXlKSkpSXl6e6SjALfGq5/HxfD0AgLt5zVYn53oAAE/wmuLjXA8A4AlesdXJ++sBADzFePFxrgcA8CSjW52c6wEAPM1o8XGuBwDwNGNbnZzrAQBMMFJ8nOsBAEzx+FYn53oAAJM8Xnyc6wEATPLoVifnegAA0zxafG+88YYOHjyopk2benJaoFbatWtnOgIAN/Bo8W3ZssWT0wEA8B1e81qdAAB4AsUHALAKxQcAsArFBwCwCsUHALAKxQcAsArFBwCwCsUHALAKxQcAsArFBwCwCsUHALAKxQcAsArFBwCwCsUHoFYaN26sTp06mY4B3LIAx3Ec0yEAAPAUVnwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACrUHwAAKtQfAAAq1B8AACr/B+8Tk02vM/1tQAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from lambeq import remove_cups\n",
    "\n",
    "train_diagrams = [remove_cups(diagram) for diagram in raw_train_diagrams]\n",
    "dev_diagrams = [remove_cups(diagram) for diagram in raw_dev_diagrams]\n",
    "test_diagrams = [remove_cups(diagram) for diagram in raw_test_diagrams]\n",
    "\n",
    "train_diagrams[0].draw()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create DisCoPy circuits"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAdYAAAJOCAYAAAAKxybpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjUuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/YYfK9AAAACXBIWXMAAAsTAAALEwEAmpwYAABdX0lEQVR4nO3deVhUZf8/8DeLIooluKFQA4giMsCggIqKC4L6oJiUWupTpLgluZZLmRumtqiJS5pLmBKalnulj4DlUiLgsLgkAo6AuCuBsg3cvz/8Or/IDfAww+D7dV1el2fOfe77c2bK95xl7mMghBAgIiIiSRjqugAiIqLahMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSajWB2tpaSl27NiB4OBg/PHHH7ouh4iIarlaG6wlJSX47rvv4OTkhKVLl8LGxgZvvfUWevXqhejoaAghdF0iERHVQgailiVMUVERwsPDsWTJEtjY2GD27Nno1asXDAwMUFJSgoiICCxevBgWFhb4+OOP4e/vDwMDA12XTUREtUStCdZ79+7hm2++wdKlS+Hi4oKPP/4YXbp0eWzb0tJS7Ny5E4sWLYKhoSE++ugjBAYGwsjISMtVExFRbaP3p4Jzc3OxaNEi2NnZ4fjx49i7dy9+/vnncqH666+/wsHBAfb29liyZAmMjIwwdOhQKJVKLFiwAF9++SXkcjm+++47lJSU6HBviIhI3+ntEevNmzexYsUKfP311+jXrx9mzZqFdu3aPdKutLQUbdq0wf/+9z9YW1vDw8MDkZGR5doKIRAVFYVP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OHbsGC5dugR7e3vMmjUL169fBwDcu3cPX331FVq1aoU9e/Zgy5YtiImJgY+PDwwMDHRcPRHRA7UmWP+pW7du+PXXX/HTTz8hOjoadnZ2GD58ONq1a4eCggKcPn0aGzZsgL29va5Lpcdo06YNNm3ahISEBPz9999o27Ythg8fDjs7Oxw7dgx79+7Fzz//jC5duui6VCKiRxgIUU2/WalBUlJScOjQIQwbNgyWlpa6LocqKScnB5GRkejbty/atWun63KoCgICAhAcHIyAgABdl0JU7XT2dBttksvlPN2rx1q0aIGpU6fqugwiogqplaeCiYiIdIXBSkREJCEGKxERkYQYrERERBJisBJRtWvVqhVefvllXZdBpBUvxM9tiIiItIVHrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJiMFKREQkIQYrERGRhBisREREEmKwEhERSYjBSkREJCEGKxERkYQYrERERBJisBIREUmIwUpERCQhBisREZGEGKxEREQSYrASERFJ6P8BxJa090fWX5AAAAAASUVORK5CYII=",
      "text/plain": [
       "<Figure size 432x576 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from lambeq import AtomicType, IQPAnsatz\n",
    "\n",
    "ansatz = IQPAnsatz({AtomicType.NOUN: 1, AtomicType.SENTENCE: 1},\n",
    "                   n_layers=1, n_single_qubit_params=3)\n",
    "\n",
    "train_circuits = [ansatz(diagram) for diagram in train_diagrams]\n",
    "dev_circuits =  [ansatz(diagram) for diagram in dev_diagrams]\n",
    "test_circuits = [ansatz(diagram) for diagram in test_diagrams]\n",
    "\n",
    "train_circuits[0].draw(figsize=(6, 8))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Create (pure quantum) model and initialise parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "from lambeq import PennyLaneModel\n",
    "\n",
    "all_circuits = train_circuits + dev_circuits + test_circuits\n",
    "\n",
    "model = PennyLaneModel.from_diagrams(all_circuits)\n",
    "model.initialise_weights()\n",
    "model = model.double()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Prepare train dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "from lambeq import Dataset\n",
    "\n",
    "train_dataset = Dataset(train_circuits,\n",
    "                        train_labels,\n",
    "                        batch_size=BATCH_SIZE)\n",
    "\n",
    "val_dataset = Dataset(dev_circuits, dev_labels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Training"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Using `PytorchTrainer`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def acc(y_hat, y):\n",
    "    return (torch.argmax(y_hat, dim=1) == \n",
    "            torch.argmax(y, dim=1)).sum().item()/len(y)\n",
    "\n",
    "def loss(y_hat, y):\n",
    "    return torch.nn.functional.mse_loss(y_hat, y.double())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Epoch 1:   train/loss: 0.2386   valid/loss: 0.1175   train/acc: 0.6429   valid/acc: 0.9000\n",
      "Epoch 2:   train/loss: 0.0845   valid/loss: 0.0676   train/acc: 0.8857   valid/acc: 0.9333\n",
      "Epoch 3:   train/loss: 0.0357   valid/loss: 0.0626   train/acc: 0.9857   valid/acc: 0.9667\n",
      "Epoch 4:   train/loss: 0.0328   valid/loss: 0.0299   train/acc: 0.9714   valid/acc: 0.9667\n",
      "Epoch 5:   train/loss: 0.0144   valid/loss: 0.0213   train/acc: 0.9857   valid/acc: 1.0000\n",
      "Epoch 6:   train/loss: 0.0092   valid/loss: 0.0181   train/acc: 1.0000   valid/acc: 1.0000\n",
      "Epoch 7:   train/loss: 0.0062   valid/loss: 0.0173   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 8:   train/loss: 0.0083   valid/loss: 0.0215   train/acc: 1.0000   valid/acc: 1.0000\n",
      "Epoch 9:   train/loss: 0.0113   valid/loss: 0.0323   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 10:  train/loss: 0.0100   valid/loss: 0.0237   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 11:  train/loss: 0.0071   valid/loss: 0.0194   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 12:  train/loss: 0.0076   valid/loss: 0.0196   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 13:  train/loss: 0.0060   valid/loss: 0.0182   train/acc: 1.0000   valid/acc: 1.0000\n",
      "Epoch 14:  train/loss: 0.0085   valid/loss: 0.0216   train/acc: 1.0000   valid/acc: 0.9667\n",
      "Epoch 15:  train/loss: 0.0084   valid/loss: 0.0250   train/acc: 1.0000   valid/acc: 0.9667\n",
      "\n",
      "Training completed!\n"
     ]
    }
   ],
   "source": [
    "from lambeq import PytorchTrainer\n",
    "\n",
    "trainer = PytorchTrainer(\n",
    "        model=model,\n",
    "        loss_function=loss,\n",
    "        optimizer=torch.optim.Adam,\n",
    "        learning_rate=0.1,\n",
    "        epochs=EPOCHS,\n",
    "        evaluate_functions={\"acc\": acc},\n",
    "        evaluate_on_train=True,\n",
    "        use_tensorboard=False,\n",
    "        verbose='text',\n",
    "        seed=SEED\n",
    "    )\n",
    "\n",
    "trainer.fit(train_dataset, val_dataset)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Determine test accuracy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.0"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def accuracy(circs, labels):\n",
    "    probs = model(circs)\n",
    "    return (torch.argmax(probs, dim=1) == \n",
    "            torch.argmax(torch.tensor(labels), dim=1)).sum().item()/len(circs)\n",
    "\n",
    "accuracy(test_circuits, test_labels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Using standard PyTorch\n",
    "\n",
    "As we have a small dataset, we can use early stopping to prevent overfitting to the training data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def accuracy(circs, labels):\n",
    "    probs = model(circs)\n",
    "    return (torch.argmax(probs, dim=1) == \n",
    "            torch.argmax(torch.tensor(labels), dim=1)).sum().item()/len(circs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch: 0\n",
      "Train loss: 1.40214268863387\n",
      "Dev acc: 0.6666666666666666\n",
      "Epoch: 5\n",
      "Train loss: 0.09461445044355091\n",
      "Dev acc: 1.0\n",
      "Epoch: 10\n",
      "Train loss: 0.03627023935725044\n",
      "Dev acc: 1.0\n"
     ]
    }
   ],
   "source": [
    "model = PennyLaneModel.from_diagrams(all_circuits)\n",
    "model.initialise_weights()\n",
    "optimizer = torch.optim.Adam(model.parameters(), lr=0.1)\n",
    "\n",
    "best = {'acc': 0, 'epoch': 0}\n",
    "\n",
    "for i in range(EPOCHS):\n",
    "    epoch_loss = 0\n",
    "    for circuits, labels in train_dataset:\n",
    "        optimizer.zero_grad()\n",
    "        probs = model(circuits)\n",
    "        loss = torch.nn.functional.mse_loss(probs, \n",
    "                                            torch.tensor(labels).double())\n",
    "        epoch_loss += loss.item()\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "    \n",
    "    if i % 5 == 0:\n",
    "        dev_acc = accuracy(dev_circuits, dev_labels)\n",
    "        \n",
    "        print(\"Epoch: {}\".format(i))\n",
    "        print(\"Train loss: {}\".format(epoch_loss))\n",
    "        print(\"Dev acc: {}\".format(dev_acc))\n",
    "        \n",
    "        if dev_acc > best['acc']:\n",
    "            best['acc'] = dev_acc\n",
    "            best['epoch'] = i\n",
    "            model.make_checkpoint(\"model.lt\")\n",
    "        elif i - best['epoch'] >= 10:\n",
    "            print(\"Early stopping\")\n",
    "            model = PennyLaneModel.from_checkpoint(\"model.lt\")\n",
    "            break\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Determine the test accuracy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.0"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "accuracy(test_circuits, test_labels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Creating a hybrid model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This model will take in pairs of diagrams and attempt to determine whether they are talking about the same or different topics. It does this by first running the circuits to get a probability ouput on the open wire, and then passes this output to a simple neural network. We expect the circuits to learn to output [0, 1] or [1, 0] depending on the topic they are referring to (cooking or computing), and the neural network to learn to XOR these outputs to determine whether the topics are the same (in which case it should ouput 0) or different (in which case it should output 1). PennyLane allows us to train both the circuits and the NN simultaneously using PyTorch autograd."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "BATCH_SIZE = 50\n",
    "EPOCHS = 100\n",
    "SEED = 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As the probability outputs from our circuits are guaranteed to be positive, we transform these outputs `x` by `2 * (x - 0.5)`, giving inputs to the neural network in the range [-1, 1]. This helps us to avoid \"dying ReLUs\", which could otherwise occur if all the input weights to a given neuron were negative, leading to the gradient of all these weights being 0. (A couple of alternative approaches could also involve initialising all the neural network weights to be positive, or using `LeakyReLU` as the activation function)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "from torch import nn\n",
    "\n",
    "class XORSentenceModel(PennyLaneModel):\n",
    "    def __init__(self):\n",
    "        PennyLaneModel.__init__(self)\n",
    "        \n",
    "        self.xor_net = nn.Sequential(\n",
    "            nn.Linear(4, 10),\n",
    "            nn.ReLU(),\n",
    "            nn.Linear(10, 1),\n",
    "            nn.Sigmoid()\n",
    "            )\n",
    "        \n",
    "    def forward(self, diagram_pairs):\n",
    "        a, b = zip(*diagram_pairs)\n",
    "        evaluated_pairs = torch.cat((self.get_diagram_output(a),\n",
    "                                     self.get_diagram_output(b)),\n",
    "                                    dim=1)\n",
    "        evaluated_pairs = 2 * (evaluated_pairs - 0.5)\n",
    "        out = self.xor_net(evaluated_pairs)\n",
    "        return out\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Make paired dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "from itertools import combinations\n",
    "\n",
    "def make_pair_data(diagrams, labels):\n",
    "    pair_diags = list(combinations(diagrams, 2))\n",
    "    pair_labels = [int(x[0] == y[0]) for x, y in combinations(labels, 2)]\n",
    "    \n",
    "    return pair_diags, pair_labels\n",
    "\n",
    "train_pair_circuits, train_pair_labels = make_pair_data(train_circuits, \n",
    "                                                        train_labels)\n",
    "dev_pair_circuits, dev_pair_labels = make_pair_data(dev_circuits, dev_labels)\n",
    "test_pair_circuits, test_pair_labels = make_pair_data(test_circuits, \n",
    "                                                      test_labels)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are lots of pairs (2415 train pairs), so we'll sample a subset to make this example train more quickly."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_pair_circuits, train_pair_labels = (\n",
    "    zip(*random.sample(list(zip(train_pair_circuits, train_pair_labels)),\n",
    "                       300)))\n",
    "dev_pair_circuits, dev_pair_labels = (\n",
    "    zip(*random.sample(list(zip(dev_pair_circuits, dev_pair_labels)), 200)))\n",
    "test_pair_circuits, test_pair_labels = (\n",
    "    zip(*random.sample(list(zip(test_pair_circuits, test_pair_labels)), 200)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initialise the model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "all_pair_circuits = (train_pair_circuits +\n",
    "                     dev_pair_circuits +\n",
    "                     test_pair_circuits)\n",
    "a, b = zip(*all_pair_circuits)\n",
    "\n",
    "model = XORSentenceModel.from_diagrams(a + b)\n",
    "model.initialise_weights()\n",
    "model = model.double()\n",
    "\n",
    "train_pair_dataset = Dataset(train_pair_circuits,\n",
    "                        train_pair_labels,\n",
    "                        batch_size=BATCH_SIZE)\n",
    "\n",
    "optimizer = torch.optim.Adam(model.parameters(), lr=0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train the model and log accuracies"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Only log every five epochs as evaluating is expensive."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def accuracy(circs, labels):\n",
    "    predicted = model(circs)\n",
    "    return (torch.round(torch.flatten(predicted)) == \n",
    "            torch.DoubleTensor(labels)).sum().item()/len(circs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch: 0\n",
      "Train loss: 4.216500047571801\n",
      "Dev acc: 0.475\n",
      "Epoch: 5\n",
      "Train loss: 0.16129305933880816\n",
      "Dev acc: 1.0\n",
      "Epoch: 10\n",
      "Train loss: 0.0008051177015249586\n",
      "Dev acc: 1.0\n",
      "Epoch: 15\n",
      "Train loss: 0.00016974739709550384\n",
      "Dev acc: 1.0\n",
      "Early stopping\n"
     ]
    }
   ],
   "source": [
    "best = {'acc': 0, 'epoch': 0}\n",
    "\n",
    "for i in range(EPOCHS):\n",
    "    epoch_loss = 0\n",
    "    for circuits, labels in train_pair_dataset:\n",
    "        optimizer.zero_grad()\n",
    "        predicted = model(circuits)\n",
    "        loss = torch.nn.functional.binary_cross_entropy(\n",
    "            torch.flatten(predicted), torch.DoubleTensor(labels))\n",
    "        epoch_loss += loss.item()\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "    \n",
    "    if i % 5 == 0:\n",
    "        dev_acc = accuracy(dev_pair_circuits, dev_pair_labels)\n",
    "        \n",
    "        print(\"Epoch: {}\".format(i))\n",
    "        print(\"Train loss: {}\".format(epoch_loss))\n",
    "        print(\"Dev acc: {}\".format(dev_acc))\n",
    "        \n",
    "        if dev_acc > best['acc']:\n",
    "            best['acc'] = dev_acc\n",
    "            best['epoch'] = i\n",
    "            model.make_checkpoint(\"xor_model.lt\")\n",
    "        elif i - best['epoch'] >= 10:\n",
    "            print(\"Early stopping\")\n",
    "            model = XORSentenceModel.from_checkpoint(\"xor_model.lt\")\n",
    "            model = model.double()\n",
    "            break"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.0"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "accuracy(test_pair_circuits, test_pair_labels)"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
